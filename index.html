<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML æ–‡ä»¶ç´¢å¼• (åŒ…å«å­æ–‡ä»¶å¤¾)</title>
    <style>
        body { 
            font-family: 'Segoe UI', Arial, sans-serif; 
            max-width: 1000px; 
            margin: 0 auto; 
            padding: 20px; 
            line-height: 1.6;
            color: #333;
        }
        h1 { 
            color: #2c3e50; 
            text-align: center; 
            border-bottom: 3px solid #3498db;
            padding-bottom: 15px;
            margin-bottom: 30px;
        }
        .stats {
            background: #e8f4fd;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 25px;
            border-left: 4px solid #3498db;
        }
        .file-list { 
            list-style: none; 
            padding: 0; 
        }
        .file-item { 
            padding: 16px 20px; 
            margin-bottom: 10px; 
            border-left: 5px solid #27ae60; 
            background: linear-gradient(to right, #f8f9fa, #ffffff);
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            transition: all 0.3s;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 10px;
        }
        .file-item:hover { 
            background: linear-gradient(to right, #f0f8ff, #f8f9fa);
            transform: translateX(8px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .file-link { 
            text-decoration: none; 
            color: #2980b9; 
            font-weight: 600;
            font-size: 17px;
            flex: 1;
            min-width: 200px;
        }
        .file-link:hover { 
            text-decoration: underline; 
            color: #1a5276;
        }
        .file-folder {
            background: #3498db;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }
        .file-date { 
            color: #7f8c8d; 
            font-size: 14px; 
            background: #ecf0f1;
            padding: 2px 10px;
            border-radius: 12px;
            white-space: nowrap;
        }
        .file-size {
            color: #7f8c8d;
            font-size: 14px;
            background: #f8f9fa;
            padding: 2px 10px;
            border-radius: 12px;
            border: 1px solid #dfe6e9;
        }
        .file-path {
            color: #95a5a6;
            font-size: 13px;
            margin-top: 5px;
            font-family: 'Consolas', monospace;
            width: 100%;
        }
        .loading { 
            text-align: center; 
            color: #7f8c8d; 
            font-style: italic;
            padding: 40px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .error {
            color: #c0392b;
            text-align: center;
            padding: 25px;
            background: #fdedec;
            border-radius: 8px;
            margin: 25px 0;
            border-left: 4px solid #e74c3c;
        }
        .empty { 
            text-align: center; 
            color: #7f8c8d; 
            font-style: italic; 
            padding: 40px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .progress {
            margin: 20px 0;
            padding: 15px;
            background: #e8f5e8;
            border-radius: 8px;
            text-align: center;
        }
        .folder-tree {
            background: #f1f8e9;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #8bc34a;
        }
        .folder-item {
            padding: 5px 0;
            color: #558b2f;
            font-family: 'Consolas', monospace;
        }
        .depth-0 { margin-left: 0px; }
        .depth-1 { margin-left: 20px; }
        .depth-2 { margin-left: 40px; }
        .depth-3 { margin-left: 60px; }
        .depth-4 { margin-left: 80px; }
        .depth-5 { margin-left: 100px; }
    </style>
</head>
<body>
    <h1>ğŸ“ HTML æ–‡ä»¶ç´¢å¼• (åŒ…å«æ‰€æœ‰å­æ–‡ä»¶å¤¾)</h1>
    
    <div id="stats" class="stats">
        ç‹€æ…‹: æº–å‚™å°±ç·’ï¼Œæ­£åœ¨æƒææ–‡ä»¶...
    </div>
    
    <div id="folderTree" class="folder-tree" style="display: none;">
        <h3>ğŸ“‚ æƒæçš„æ–‡ä»¶å¤¾çµæ§‹:</h3>
        <div id="folderList"></div>
    </div>
    
    <div id="content" class="loading">
        <p>ğŸ” æ­£åœ¨æƒæç•¶å‰ç›®éŒ„å’Œæ‰€æœ‰å­æ–‡ä»¶å¤¾ä¸­çš„ HTML æ–‡ä»¶...</p>
        <p>è«‹ç¨å€™ï¼Œé€™å¯èƒ½éœ€è¦ä¸€äº›æ™‚é–“ï¼Œå–æ±ºæ–¼æ–‡ä»¶æ•¸é‡</p>
    </div>

    <script>
        class HTMLFileScanner {
            constructor() {
                this.allFiles = [];
                this.scannedFolders = new Set();
                this.folderStructure = {};
                this.stats = {
                    totalFiles: 0,
                    totalFolders: 0,
                    scanStartTime: 0,
                    scanTime: 0
                };
            }

            // ä¸»å…¥å£
            async start() {
                this.stats.scanStartTime = Date.now();
                this.updateStats('ç‹€æ…‹: æ­£åœ¨åˆå§‹åŒ–æƒæ...');
                
                try {
                    // æ–¹æ³•1: å˜—è©¦ä½¿ç”¨æœå‹™å™¨ç›®éŒ„åˆ—è¡¨ (å¦‚æœæ”¯æŒ)
                    const success = await this.scanWithDirectoryList();
                    
                    if (!success) {
                        // æ–¹æ³•2: å‚™ç”¨æ–¹æ¡ˆ - çŒœæ¸¬å¸¸è¦‹æ–‡ä»¶å¤¾çµæ§‹
                        this.updateStats('ç‹€æ…‹: ç›®éŒ„åˆ—è¡¨ä¸å¯ç”¨ï¼Œä½¿ç”¨å‚™ç”¨æ–¹æ¡ˆ...');
                        await this.scanWithFallback();
                    }
                    
                    // æ’åºä¸¦é¡¯ç¤ºçµæœ
                    this.sortAndDisplay();
                    
                } catch (error) {
                    console.error('æƒæéŒ¯èª¤:', error);
                    this.showError(`æƒæå¤±æ•—: ${error.message}`);
                }
            }

            // æ–¹æ³•1: ä½¿ç”¨æœå‹™å™¨ç›®éŒ„åˆ—è¡¨ (æ¨è–¦)
            async scanWithDirectoryList() {
                this.updateStats('ç‹€æ…‹: å˜—è©¦ä½¿ç”¨ç›®éŒ„åˆ—è¡¨åŠŸèƒ½...');
                
                try {
                    // ç²å–æ ¹ç›®éŒ„åˆ—è¡¨
                    const rootFiles = await this.fetchDirectory('./');
                    if (!rootFiles) return false;
                    
                    // æ·»åŠ åˆ°çµæœ
                    this.addFiles(rootFiles, './');
                    
                    // éæ­¸æƒæå­æ–‡ä»¶å¤¾
                    await this.scanSubdirectories(rootFiles);
                    
                    return true;
                } catch (error) {
                    console.warn('ç›®éŒ„åˆ—è¡¨æƒæå¤±æ•—:', error);
                    return false;
                }
            }

            // ç²å–å–®å€‹ç›®éŒ„çš„å…§å®¹
            async fetchDirectory(path) {
                try {
                    const response = await fetch(path, {
                        headers: { 'X-Requested-With': 'XMLHttpRequest' }
                    });
                    
                    if (!response.ok) return null;
                    
                    const html = await response.text();
                    return this.parseDirectoryHTML(html, path);
                } catch (error) {
                    console.warn(`ç„¡æ³•ç²å–ç›®éŒ„ ${path}:`, error);
                    return null;
                }
            }

            // è§£æç›®éŒ„åˆ—è¡¨ HTML
            parseDirectoryHTML(html, basePath) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                const files = [];
                
                // å¸¸è¦‹ç›®éŒ„åˆ—è¡¨é¸æ“‡å™¨
                const selectors = [
                    'a[href]',           // Apache
                    'table a[href]',     // Nginx
                    'pre a[href]'        // ç°¡å–®åˆ—è¡¨
                ];
                
                let links = [];
                for (const selector of selectors) {
                    links = links.concat(Array.from(doc.querySelectorAll(selector)));
                    if (links.length > 0) break;
                }
                
                links.forEach(link => {
                    const href = link.getAttribute('href');
                    const text = link.textContent.trim();
                    
                    if (!href || href.startsWith('?') || href === '../' || 
                        href === basePath || href === basePath.replace('./', '')) {
                        return;
                    }
                    
                    // åˆ¤æ–·æ˜¯æ–‡ä»¶é‚„æ˜¯æ–‡ä»¶å¤¾
                    const isDirectory = href.endsWith('/');
                    const name = isDirectory ? href.slice(0, -1) : href;
                    const fullPath = this.joinPath(basePath, href);
                    
                    // æå–æ—¥æœŸå’Œå¤§å°
                    const info = this.extractFileInfo(link, isDirectory);
                    
                    files.push({
                        name: name,
                        path: fullPath,
                        isDirectory: isDirectory,
                        date: info.date,
                        size: info.size,
                        rawText: text
                    });
                });
                
                return files;
            }

            // éæ­¸æƒæå­æ–‡ä»¶å¤¾
            async scanSubdirectories(files) {
                const folderPromises = [];
                
                for (const file of files) {
                    if (file.isDirectory && !this.scannedFolders.has(file.path)) {
                        this.scannedFolders.add(file.path);
                        this.stats.totalFolders++;
                        this.addToFolderStructure(file.path, file.name);
                        
                        // ä¸¦ç™¼æƒæå­æ–‡ä»¶å¤¾
                        const promise = (async () => {
                            const subFiles = await this.fetchDirectory(file.path);
                            if (subFiles) {
                                this.addFiles(subFiles, file.path);
                                await this.scanSubdirectories(subFiles); // éæ­¸
                            }
                        })();
                        
                        folderPromises.push(promise);
                    }
                }
                
                // ç­‰å¾…æ‰€æœ‰å­æ–‡ä»¶å¤¾æƒæå®Œæˆ
                if (folderPromises.length > 0) {
                    this.updateStats(`ç‹€æ…‹: æ­£åœ¨æƒæ ${folderPromises.length} å€‹å­æ–‡ä»¶å¤¾...`);
                    await Promise.all(folderPromises);
                }
            }

            // æ–¹æ³•2: å‚™ç”¨æ–¹æ¡ˆ - çŒœæ¸¬æ–‡ä»¶å¤¾çµæ§‹
            async scanWithFallback() {
                this.updateStats('ç‹€æ…‹: ä½¿ç”¨å‚™ç”¨æ–¹æ¡ˆæƒæå¸¸è¦‹æ–‡ä»¶å¤¾...');
                
                // å¸¸è¦‹æ–‡ä»¶å¤¾æ¨¡å¼
                const commonFolders = [
                    // æ—¥æœŸæ ¼å¼æ–‡ä»¶å¤¾
                    ...this.generateDateFolders(365 * 3), // éå»3å¹´
                    // å¸¸è¦‹åç¨±
                    'docs', 'documents', 'articles', 'posts', 'pages',
                    'html', 'web', 'site', 'content', 'files',
                    '2023', '2024', '2025', 'archive', 'old',
                    'news', 'blog', 'products', 'services'
                ];
                
                const filePromises = [];
                
                // 1. æª¢æŸ¥å¸¸è¦‹æ–‡ä»¶å¤¾
                for (const folder of commonFolders) {
                    filePromises.push(this.checkFolderExists(folder));
                }
                
                // 2. æª¢æŸ¥æ·±å±¤æ–‡ä»¶å¤¾
                for (let depth = 1; depth <= 3; depth++) {
                    const deepFolders = this.generateDeepFolders(depth);
                    for (const folder of deepFolders) {
                        filePromises.push(this.checkFolderExists(folder));
                    }
                }
                
                // 3. æª¢æŸ¥å¸¸è¦‹æ–‡ä»¶å
                const commonFiles = this.generateCommonFiles();
                for (const file of commonFiles) {
                    filePromises.push(this.checkFileExists(file));
                }
                
                // ä¸¦ç™¼è™•ç†æ‰€æœ‰æª¢æŸ¥
                this.updateStats(`ç‹€æ…‹: æ­£åœ¨æª¢æŸ¥ ${filePromises.length} å€‹å¯èƒ½çš„è·¯å¾‘...`);
                const results = await Promise.allSettled(filePromises);
                
                // è™•ç†çµæœ
                for (const result of results) {
                    if (result.status === 'fulfilled' && result.value) {
                        const { type, path, name, parent } = result.value;
                        
                        if (type === 'file') {
                            this.allFiles.push({
                                name: name,
                                path: path,
                                folder: parent,
                                date: new Date(0),
                                size: null
                            });
                            this.stats.totalFiles++;
                        } else if (type === 'folder') {
                            this.scannedFolders.add(path);
                            this.stats.totalFolders++;
                            this.addToFolderStructure(path, name);
                        }
                    }
                }
            }

            // æª¢æŸ¥æ–‡ä»¶å¤¾æ˜¯å¦å­˜åœ¨
            async checkFolderExists(folderPath) {
                try {
                    const response = await fetch(folderPath, { 
                        method: 'HEAD',
                        headers: { 'X-Requested-With': 'XMLHttpRequest' }
                    });
                    
                    if (response.ok) {
                        return { type: 'folder', path: folderPath, name: this.getFolderName(folderPath) };
                    }
                } catch (error) {
                    // å¿½ç•¥éŒ¯èª¤
                }
                return null;
            }

            // æª¢æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
            async checkFileExists(filePath) {
                try {
                    const response = await fetch(filePath, { 
                        method: 'HEAD',
                        headers: { 'X-Requested-With': 'XMLHttpRequest' }
                    });
                    
                    if (response.ok && filePath.match(/\.html?$/i) && filePath !== 'index.html') {
                        const parent = this.getParentFolder(filePath);
                        return { 
                            type: 'file', 
                            path: filePath, 
                            name: this.getFileName(filePath),
                            parent: parent
                        };
                    }
                } catch (error) {
                    // å¿½ç•¥éŒ¯èª¤
                }
                return null;
            }

            // ç”Ÿæˆæ—¥æœŸæ–‡ä»¶å¤¾ (å¦‚ 20240808, 2024-08-08)
            generateDateFolders(days) {
                const folders = [];
                const today = new Date();
                
                for (let i = 0; i < days; i++) {
                    const date = new Date(today);
                    date.setDate(date.getDate() - i);
                    
                    // æ ¼å¼: YYYYMMDD
                    const yyyymmdd = date.toISOString().slice(0, 10).replace(/-/g, '');
                    folders.push(yyyymmdd);
                    
                    // æ ¼å¼: YYYY-MM-DD
                    const yyyy_mm_dd = date.toISOString().slice(0, 10);
                    folders.push(yyyy_mm_dd);
                    
                    // æ ¼å¼: YYYY/MM/DD (æ·±å±¤)
                    const year = date.getFullYear();
                    const month = String(date.getMonth() + 1).padStart(2, '0');
                    const day = String(date.getDate()).padStart(2, '0');
                    folders.push(`${year}/${month}/${day}`);
                    folders.push(`${year}/${month}`);
                }
                
                return folders;
            }

            // ç”Ÿæˆæ·±å±¤æ–‡ä»¶å¤¾çµæ§‹
            generateDeepFolders(depth) {
                const folders = [];
                const commonNames = ['docs', 'articles', 'pages', 'posts', 'content'];
                
                if (depth === 1) {
                    return commonNames;
                }
                
                for (let d = 2; d <= depth; d++) {
                    for (const name of commonNames) {
                        for (let i = 0; i < 5; i++) {
                            if (d === 2) {
                                folders.push(`${name}/${i}`);
                            } else if (d === 3) {
                                folders.push(`${name}/${i}/${i}`);
                            }
                        }
                    }
                }
                
                return folders;
            }

            // ç”Ÿæˆå¸¸è¦‹æ–‡ä»¶å
            generateCommonFiles() {
                const files = [];
                const commonNames = [
                    'index', 'home', 'main', 'page', 'article', 'post', 'doc',
                    'news', 'blog', 'product', 'service', 'about', 'contact'
                ];
                
                // æ ¹ç›®éŒ„æ–‡ä»¶
                for (const name of commonNames) {
                    files.push(`${name}.html`);
                    files.push(`${name}.htm`);
                }
                
                // æ—¥æœŸæ–‡ä»¶å
                const today = new Date();
                for (let i = 0; i < 30; i++) {
                    const date = new Date(today);
                    date.setDate(date.getDate() - i);
                    const dateStr = date.toISOString().slice(0, 10).replace(/-/g, '');
                    
                    files.push(`${dateStr}.html`);
                    files.push(`${dateStr}_post.html`);
                    files.push(`post_${dateStr}.html`);
                }
                
                return files;
            }

            // æå–æ–‡ä»¶ä¿¡æ¯ (æ—¥æœŸã€å¤§å°)
            extractFileInfo(element, isDirectory) {
                const parentText = element.parentElement?.textContent || '';
                let date = new Date(0);
                let size = null;
                
                // æ—¥æœŸæ¨¡å¼
                const datePatterns = [
                    /\d{4}[-å¹´]\d{1,2}[-æœˆ]\d{1,2}/,           // 2023-08-15
                    /\d{4}\/\d{1,2}\/\d{1,2}/,                 // 2023/08/15  
                    /\d{1,2}[-æœˆ]\d{1,2}[-æ—¥]\s*\d{4}/,         // 8æœˆ15æ—¥ 2023
                    /\d{4}å¹´\d{1,2}æœˆ\d{1,2}æ—¥/,                // 2023å¹´8æœˆ15æ—¥
                ];
                
                for (const pattern of datePatterns) {
                    const match = parentText.match(pattern);
                    if (match) {
                        let dateStr = match[0].replace(/å¹´|æœˆ/g, '-').replace(/æ—¥/g, '');
                        dateStr = dateStr.replace(/[-/]/g, '-');
                        const parsedDate = new Date(dateStr);
                        if (!isNaN(parsedDate.getTime())) {
                            date = parsedDate;
                            break;
                        }
                    }
                }
                
                // å¤§å°æ¨¡å¼
                const sizePatterns = [
                    /\d+(\.\d+)?\s*KB/i,
                    /\d+(\.\d+)?\s*MB/i,
                    /\d+\s*bytes?/i
                ];
                
                for (const pattern of sizePatterns) {
                    const match = parentText.match(pattern);
                    if (match) {
                        size = match[0];
                        break;
                    }
                }
                
                return { date, size };
            }

            // æ·»åŠ æ–‡ä»¶åˆ°çµæœ
            addFiles(files, parentPath) {
                for (const file of files) {
                    if (!file.isDirectory && 
                        file.name.match(/\.html?$/i) && 
                        file.name !== 'index.html') {
                        
                        this.allFiles.push({
                            name: file.name,
                            path: file.path,
                            folder: parentPath,
                            date: file.date || new Date(0),
                            size: file.size
                        });
                        
                        this.stats.totalFiles++;
                    }
                }
            }

            // æ·»åŠ åˆ°æ–‡ä»¶å¤¾çµæ§‹
            addToFolderStructure(path, name) {
                const parts = path.split('/').filter(p => p);
                let current = this.folderStructure;
                
                for (let i = 0; i < parts.length; i++) {
                    const part = parts[i];
                    if (!current[part]) {
                        current[part] = { name: part, children: {} };
                    }
                    current = current[part].children;
                }
            }

            // æ’åºä¸¦é¡¯ç¤º
            sortAndDisplay() {
                this.stats.scanTime = ((Date.now() - this.stats.scanStartTime) / 1000).toFixed(2);
                
                // æŒ‰æ—¥æœŸé™åºæ’åº (æœ€æ–°çš„åœ¨å‰)
                this.allFiles.sort((a, b) => {
                    // å¦‚æœæœ‰æ—¥æœŸï¼ŒæŒ‰æ—¥æœŸæ’åº
                    if (a.date && b.date && a.date.getTime() !== 0 && b.date.getTime() !== 0) {
                        return b.date - a.date;
                    }
                    // å¦å‰‡æŒ‰è·¯å¾‘æ’åº (æœ€æ–°çš„æ–‡ä»¶å¤¾åœ¨å‰)
                    return b.path.localeCompare(a.path);
                });
                
                // é¡¯ç¤ºçµæœ
                this.displayResults();
                this.displayFolderTree();
                
                // æ›´æ–°çµ±è¨ˆ
                this.updateStats(`
                    âœ… æƒæå®Œæˆ! <br>
                    æ–‡ä»¶æ•¸é‡: <strong>${this.stats.totalFiles}</strong> | 
                    æ–‡ä»¶å¤¾æ•¸é‡: <strong>${this.stats.totalFolders}</strong> | 
                    è€—æ™‚: <strong>${this.stats.scanTime}</strong> ç§’
                `);
            }

            // é¡¯ç¤ºçµæœ
            displayResults() {
                const contentDiv = document.getElementById('content');
                
                if (this.allFiles.length === 0) {
                    contentDiv.innerHTML = `
                        <div class="error">
                            <h3>âŒ æ²’æœ‰æ‰¾åˆ°ä»»ä½• HTML æ–‡ä»¶</h3>
                            <p>å¯èƒ½çš„åŸå› :</p>
                            <ul style="text-align: left; margin: 15px 0;">
                                <li>æœå‹™å™¨ç¦ç”¨äº†ç›®éŒ„åˆ—è¡¨åŠŸèƒ½</li>
                                <li>æ²’æœ‰ HTML æ–‡ä»¶ (é™¤äº† index.html)</li>
                                <li>æ–‡ä»¶å¤¾çµæ§‹éå¸¸ä¸å¸¸è¦‹</li>
                            </ul>
                            <p>è§£æ±ºæ–¹æ³•:</p>
                            <ol style="text-align: left; margin: 15px 0;">
                                <li><strong>å•Ÿç”¨ç›®éŒ„åˆ—è¡¨</strong>: é…ç½®æ‚¨çš„ Web æœå‹™å™¨</li>
                                <li><strong>æ‰‹å‹•æ·»åŠ æ–‡ä»¶</strong>: ç·¨è¼¯ index.html</li>
                                <li><strong>æª¢æŸ¥æ–‡ä»¶è·¯å¾‘</strong>: ç¢ºä¿æ–‡ä»¶å­˜åœ¨</li>
                            </ol>
                        </div>`;
                    return;
                }
                
                const filesHTML = this.allFiles.map(file => {
                    const dateStr = file.date && file.date.getTime() > 0 
                        ? this.formatDate(file.date) 
                        : 'æœªçŸ¥æ—¥æœŸ';
                    
                    const folderName = this.getFolderName(file.folder);
                    const sizeStr = file.size ? `<span class="file-size">${file.size}</span>` : '';
                    
                    return `
                    <div class="file-item">
                        <a href="${file.path}" class="file-link" target="_blank">
                            ${this.escapeHtml(this.getTitleFromFilename(file.name))}
                        </a>
                        <span class="file-folder">${this.escapeHtml(folderName)}</span>
                        <span class="file-date">${dateStr}</span>
                        ${sizeStr}
                        <div class="file-path">${this.escapeHtml(file.path)}</div>
                    </div>`;
                }).join('');
                
                contentDiv.innerHTML = `
                    <p>æ‰¾åˆ° <strong>${this.allFiles.length}</strong> å€‹ HTML æ–‡ä»¶:</p>
                    <div class="file-list">${filesHTML}</div>
                `;
            }

            // é¡¯ç¤ºæ–‡ä»¶å¤¾æ¨¹
            displayFolderTree() {
                if (this.scannedFolders.size === 0) return;
                
                const treeDiv = document.getElementById('folderList');
                const folders = Array.from(this.scannedFolders).sort();
                
                const treeHTML = folders.map(folder => {
                    const depth = folder.split('/').filter(p => p).length - 1;
                    const name = this.getFolderName(folder);
                    return `<div class="folder-item depth-${Math.min(depth, 5)}">${'ğŸ“ '.repeat(depth)}${this.escapeHtml(name)}</div>`;
                }).join('');
                
                document.getElementById('folderTree').style.display = 'block';
                treeDiv.innerHTML = treeHTML;
            }

            // å·¥å…·å‡½æ•¸
            joinPath(base, path) {
                if (base === './') return path;
                if (base.endsWith('/') && path.startsWith('/')) {
                    return base + path.slice(1);
                }
                if (!base.endsWith('/') && !path.startsWith('/')) {
                    return base + '/' + path;
                }
                return base + path;
            }

            getParentFolder(path) {
                const parts = path.split('/');
                parts.pop(); // ç§»é™¤æ–‡ä»¶å
                return parts.join('/') || './';
            }

            getFolderName(path) {
                const parts = path.split('/');
                return parts[parts.length - 1] || 'æ ¹ç›®éŒ„';
            }

            getFileName(path) {
                const parts = path.split('/');
                return parts[parts.length - 1];
            }

            getTitleFromFilename(filename) {
                return filename
                    .replace(/\.html?$/i, '')
                    .replace(/[-_]/g, ' ')
                    .replace(/\b\w/g, l => l.toUpperCase());
            }

            formatDate(date) {
                return date.toLocaleDateString('zh-TW', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            updateStats(text) {
                document.getElementById('stats').innerHTML = text;
            }

            showError(message) {
                document.getElementById('content').innerHTML = `
                    <div class="error">
                        <h3>âŒ æƒæéŒ¯èª¤</h3>
                        <p>${this.escapeHtml(message)}</p>
                    </div>`;
            }
        }

        // å•Ÿå‹•æƒæ
        document.addEventListener('DOMContentLoaded', () => {
            const scanner = new HTMLFileScanner();
            scanner.start();
        });
    </script>
</body>
</html>
